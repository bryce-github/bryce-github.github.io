{"version":3,"sources":["blog/posts/python-units-1/Post.js"],"names":["info","codeBlock1","trim","codeBlock2","codeBlock3","codeBlock4","codeBlock6","codeBlock7","codeBlock8","codeBlock9","Post","className","language","style","docco","href"],"mappings":"6MAIMA,EACE,iEADFA,EAEE,cAIFC,EAAa,4HAKjBC,OAEIC,EAAa,sKAIjBD,OAEIE,EAAa,sQASjBF,OAEIG,EAAa,4IAIjBH,OAQII,GANa,4IAIjBJ,OAEiB,qRAUjBA,QAEIK,EAAa,ifAejBL,OAEIM,EAAa,iIAKjBN,OAEIO,EAAa,8MAMjBP,OAEa,SAASQ,IACtB,OACE,gCACE,6BAAKV,IACL,mBAAGW,UAAU,WAAb,SAAyBX,IACzB,maAQA,sDACA,6PAIW,4CAJX,6PASA,cAAC,IAAD,CAAmBY,SAAS,SAASC,MAAOC,IAA5C,SACKb,IAEL,kDACqB,+CADrB,eACyD,8CADzD,0LAImC,mCAJnC,2EAKsC,2CALtC,QAK+D,4CAL/D,OAOA,kEACA,8BACI,2CADJ,gEAEY,4CAFZ,wHAIS,4CAJT,uCAKI,2CALJ,0CAOA,+LAKA,cAAC,IAAD,CAAmBW,SAAS,SAASC,MAAOC,IAA5C,SACKX,IAEL,qHAEqB,2CAFrB,wCAGO,4CAHP,qDAIa,2CAJb,kDAKS,4CALT,yFAQA,iFACkD,2CADlD,OAEE,4CAFF,iCAIA,cAAC,IAAD,CAAmBS,SAAS,SAASC,MAAOC,IAA5C,SACKV,IAEL,iKAIA,cAAC,IAAD,CAAmBQ,SAAS,SAASC,MAAOC,IAA5C,SACKT,IAEL,gFACiD,qCADjD,sIAGsD,2CAHtD,oBAMA,qLAGU,4CAHV,sGAKU,4CALV,oBAOA,gLAGM,4CAHN,iFAIsC,yCAJtC,+BAKqB,yCALrB,kEAM6B,2CAN7B,0CAOoB,4CAPpB,kDAUA,cAAC,IAAD,CAAmBO,SAAS,SAASC,MAAOC,IAA5C,SACKR,IAEL,wDACA,wPAMA,+BACE,+BAAI,wDAAJ,0BACA,+BAAI,wDAAJ,6BACA,+BAAI,wDAAJ,gCACA,+BAAI,4DAAJ,0BACA,+BAAI,wDAAJ,wBACA,+BAAI,uDAAJ,2BACA,+BAAI,uDAAJ,wCACA,+BAAI,uDAAJ,2BACA,+BAAI,uDAAJ,8BACA,+BAAI,uDAAJ,8CAEF,oFACqD,mBAAGS,KAAK,6EAAR,kCADrD,2LAMA,+BACE,uEACA,6DAA+B,4CAA/B,sBAEF,iDACkB,2CADlB,6BAGA,cAAC,IAAD,CAAmBH,SAAS,SAASC,MAAOC,IAA5C,SACKP,IAEL,oHAEc,4CAFd,+MAKwC,4CALxC,wEAM0D,+CAN1D,oNAWA,cAAC,IAAD,CAAmBK,SAAS,SAASC,MAAOC,IAA5C,SACKN,IAEL,yEAC0C,4CAD1C,gDAIA,qEACsC,6CADtC,mDAE2C,4CAF3C,2FAGyD,4CAHzD,2EAIiE,2CAJjE,iFAKwE,4CALxE,yEAMgE,2CANhE,cAQA,cAAC,IAAD,CAAmBI,SAAS,SAASC,MAAOC,IAA5C,SACKL,IAEL","file":"static/js/10.2140fef5.chunk.js","sourcesContent":["import '../Post.scss';\r\nimport SyntaxHighlighter from 'react-syntax-highlighter';\r\nimport { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';\r\n\r\nconst info = {\r\n  name: \"Physical Units in Python: Part 1 - Emulating Python Primitives\",\r\n  date: \"Dec 17 2020\",\r\n  tags: [\"python\"]\r\n};\r\n  \r\nconst codeBlock1 = `\r\nclass MyNumber:\r\n    def __init__(self, value, units=None):\r\n        self._value = value\r\n        self._units = units\r\n`.trim();\r\n\r\nconst codeBlock2 = `\r\nx = MyNumber(5)\r\nprint(str(x))  # returns <__main__.MyNumber instance at 0x037B3990>\r\nprint(repr(x))  # also returns <__main__.MyNumber instance at 0x037B3990>\r\n`.trim();\r\n\r\nconst codeBlock3 = `\r\nclass MyNumber:\r\n    def __init__(self, value, units=None):\r\n        self._value = value\r\n        self._units = units\r\n    def __str__(self):\r\n        return f'my value is {self._value}'\r\n    def __repr__(self):\r\n        return f'my repr is {self._value}'\r\n`.trim();\r\n\r\nconst codeBlock4 = `\r\nx = MyNumber(5)\r\nprint(f'here is the string: {x}')  # returns here is the string: my value is 5\r\nprint([x])  # returns [my repr is 5]\r\n`.trim();\r\n\r\nconst codeBlock5 = `\r\nx = MyNumber(5)\r\nprint(f'here is the string: {x}')  # returns here is the string: my value is 5\r\nprint([x])  # returns [my repr is 5]\r\n`.trim();\r\n\r\nconst codeBlock6 = `\r\nclass MyNumber:\r\n    def __init__(self, value, units=None):\r\n        self._value = value\r\n        self._units = units\r\n    def __repr__(self):\r\n        if self._units:\r\n            return f'{self._value} {self._units}'\r\n        else:\r\n            return f'{self._value}'\r\n`.trim();\r\n\r\nconst codeBlock7 = `\r\nclass MyNumber:\r\n    def __init__(self, value, units=None):\r\n        self._value = value\r\n        self._units = units\r\n    def __repr__(self):\r\n        if self._units:\r\n            return f'{self._value} {self._units}'\r\n        else:\r\n            return f'{self._value}'\r\n    def __add__(self, other):\r\n        if isinstance(other, MyNumber):\r\n            return MyNumber(self._value + other._value, self._units)\r\n        else:\r\n            return MyNumber(self._value + other, self._units)\r\n`.trim();\r\n\r\nconst codeBlock8 = `\r\nx = MyNumber(5, 'seconds')\r\ny = x + 3\r\nprint(type(y))  # returns <class '__main__.MyNumber'\r\nprint(y)  # returns 8 seconds\r\n`.trim();\r\n\r\nconst codeBlock9 = `\r\ndef __radd__(self, other):\r\n    if isinstance(other, MyNumber):\r\n        return MyNumber(self._value + other._value, self._units)\r\n    else:\r\n        return MyNumber(self._value + other, self._units)\r\n`.trim();\r\n\r\nexport default function Post() {\r\n  return (\r\n    <div>\r\n      <h3>{info.name}</h3>\r\n      <p className=\"dateText\">{info.date}</p> \r\n      <p>\r\n          One problem that comes up when using computer programming to solve \r\n          physics problems is handling physical units like distance or time. \r\n          In this series, we'll look at developing a flexible framework for \r\n          handling units in Python. Part 1 of this series will take a look\r\n          at some prerequisite Python knowledge that will be useful when \r\n          creating something that acts like a primitive Python type.\r\n      </p>\r\n      <h4>The Python \"Dunders\"</h4>\r\n      <p>\r\n          Let's frst take a look behind the scenes to understand how Python works.\r\n          It starts with the magical functions often referred to as \"dunders\",\r\n          which is short for double underscore. The most common one Pythonistas\r\n          see is <code>__init__</code>, which is used to instantiate a class. However,\r\n          Python uses these functions for all sorts of purposes, such as adding or \r\n          subtracting. Let's make our own class and take a look at manipulating \r\n          some basic arithmetic. We'll start with a simple class.\r\n      </p>\r\n      <SyntaxHighlighter language=\"python\" style={docco}>\r\n          {codeBlock1}\r\n      </SyntaxHighlighter>\r\n      <p>\r\n          Note we're using <code>self._value</code> instead of <code>self.value</code>.\r\n          In Python, it's convention to prefix private variables with an underscore.\r\n          We're doing this because we don't want users to access the value directly.\r\n          Instead, we want this class to <i>be</i> the value. For this to happen, let's\r\n          take a look at two other dunders, <code>__str__</code> and <code>__repr__</code>.\r\n      </p>\r\n      <h4>The __str__ and __repr__ Dunders</h4>\r\n      <p>\r\n          <code>__str__</code> is the dunder method that converts an object into a \r\n          string. <code>__repr__</code> is the dunder method that converts an object \r\n          into a string representation of the object. The big difference is \r\n          that <code>__repr__</code> is meant to be unambiguous, whereas \r\n          <code>__str__</code> is just meant to be human-readable.\r\n      </p>\r\n      <p>\r\n        Let's look at a couple scenarios to understand how these behave. Let's\r\n        start with our simple class. What happens when we look at the string\r\n        and repr for this?\r\n      </p>\r\n      <SyntaxHighlighter language=\"python\" style={docco}>\r\n          {codeBlock2}\r\n      </SyntaxHighlighter>\r\n      <p>\r\n          Note these both return the same thing. This is because the default\r\n          functionality of <code>__str__</code> is to just return the same thing\r\n          as <code>__repr__</code>. This will always be the case unless we \r\n          override <code>__str__</code>. Note the memory address that's returned\r\n          from <code>__repr__</code>. This memory address is unique to this\r\n          class instance, which makes it unambiguous.\r\n      </p>\r\n      <p>\r\n        Now let's look at what happens when we override <code>__str__</code> and\r\n        <code>__repr__</code>. Here's our updated class.\r\n      </p>\r\n      <SyntaxHighlighter language=\"python\" style={docco}>\r\n          {codeBlock3}\r\n      </SyntaxHighlighter>\r\n      <p>\r\n        We should know how our previous tests should go. Let's look at some \r\n        more complicated scenarios to see how our instance shows up.\r\n      </p>\r\n      <SyntaxHighlighter language=\"python\" style={docco}>\r\n          {codeBlock4}\r\n      </SyntaxHighlighter>\r\n      <p>\r\n        In the first print statement, we're formatting <code>x</code> into a string.\r\n        This will convert it to a string and insert it into the string\r\n        that is being printed. We can see that it's calling <code>__str__</code> in\r\n        this case.\r\n      </p>\r\n      <p>\r\n        In the second print statement, we add our instance to a list, then print\r\n        that list. When we do that, Python shows us what's in that list by \r\n        calling <code>__repr__</code> for each item, since that will tell us, \r\n        unambiguously, what each item is. We can see it's \r\n        calling <code>__repr__</code> in this case.\r\n      </p>\r\n      <p>\r\n        In our case, we want it to return the value and the units. If the units\r\n        are omitted, we'll leave them out and just return the value. We'll\r\n        use <code>__repr__</code> in this case since it's intended to be a\r\n        numeric type. For now, we'll assume <code>value</code> will be \r\n        a float or int and <code>units</code> will be a string. Since neither of\r\n        these override the default <code>__str__</code>, we'll convert them \r\n        to strings in our <code>__repr__</code> to simplify the code.\r\n        Here's our new class.\r\n      </p>\r\n      <SyntaxHighlighter language=\"python\" style={docco}>\r\n          {codeBlock6}\r\n      </SyntaxHighlighter>\r\n      <h4>Dunders for Arithmetic</h4>\r\n      <p>\r\n        With that out of the way, let's take a look at some more dunders.\r\n        this time, we'll look at the ones that are used for basic arithmetic.\r\n        Here's a quick rundown of all the arithmetic dunders and what they're\r\n        used for.\r\n      </p>\r\n      <ul>\r\n        <li><code>__add__(self, other)</code> is for addition (+)</li>\r\n        <li><code>__sub__(self, other)</code> is for subtraction (-)</li>\r\n        <li><code>__mul__(self, other)</code> is for multiplication (*)</li>\r\n        <li><code>__truediv__(self, other)</code> is for division (/)</li>\r\n        <li><code>__pow__(self, other)</code> is for power (**)</li>\r\n        <li><code>__lt__(self, other)</code> is for less than (&lt;)</li>\r\n        <li><code>__le__(self, other)</code> is for less than or equal to (&lt;=)</li>\r\n        <li><code>__eq__(self, other)</code> is for equal to (==)</li>\r\n        <li><code>__gt__(self, other)</code> is for greater than (&gt;)</li>\r\n        <li><code>__ge__(self, other)</code> is for greater than or equal to (&gt;=)</li>\r\n      </ul>\r\n      <p>\r\n        This is just scratching the surface. Check out the <a href=\"https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types\">\r\n        Python documentation</a> for more information on emulating data types in Python.\r\n        For now, we'll stick to these and take a look at them in action. Let's start\r\n        with addition. We'll account for two use cases.\r\n      </p>\r\n      <ol>\r\n        <li>Adding a float or an int to our class</li>\r\n        <li>Adding another instance of <code>MyNumber</code> to our class</li>\r\n      </ol>\r\n      <p>\r\n        Let's now add a <code>__add__</code> method to handle this.\r\n      </p>\r\n      <SyntaxHighlighter language=\"python\" style={docco}>\r\n          {codeBlock7}\r\n      </SyntaxHighlighter>\r\n      <p>\r\n        We're first checking to see if the other thing we're adding is another\r\n        instance of <code>MyNumber</code>. If it is, we'll add the two\r\n        values together. Down the road, we'll probably want to handle unit \r\n        compatibility and conversion, but we'll leave it at this for now. If\r\n        the other object isn't an instance of <code>MyNumber</code>, then we'll\r\n        just add it to our value. In both cases, we leave it to <code>self._value</code> to\r\n        handle the addition. Since the value is an int or float, this will \r\n        behave just like regular int or float addition. For example, an error will be raised \r\n        if we try adding a string. Let's see it in action.\r\n      </p>\r\n      <SyntaxHighlighter language=\"python\" style={docco}>\r\n          {codeBlock8}\r\n      </SyntaxHighlighter>\r\n      <p>\r\n        Great! We see it returns an instance of <code>MyNumber</code> with the value of 8 \r\n        and units of seconds.\r\n      </p>\r\n      <p>\r\n        Note that we get an error if we try <code>y = 3 + x</code>. This\r\n        is because there's another dunder called <code>__radd__</code> that handles the case where our\r\n        object is on the right side of the addition. Note that <code>__radd__</code> is only\r\n        called when the object on the left either doesn't have its own <code>__add__</code> method\r\n        or it doesn't know how to add the two objects together. We can add an <code>__radd__</code> method\r\n        to our class to handle this case. It would look just like our <code>__add__</code> method.\r\n      </p>\r\n      <SyntaxHighlighter language=\"python\" style={docco}>\r\n          {codeBlock9}\r\n      </SyntaxHighlighter>\r\n      <p>\r\n        That's where we'll stop for now. I encourage you to test out the other dunders and get a feel\r\n        for how other arithmetic is handled. In the next post, we'll take a look at handling units. Until\r\n        then, happy coding!\r\n      </p>\r\n    </div>\r\n  )\r\n}"],"sourceRoot":""}