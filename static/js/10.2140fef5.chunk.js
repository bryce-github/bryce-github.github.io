(this.webpackJsonpwebsite=this.webpackJsonpwebsite||[]).push([[10],{67:function(e,t,s){},89:function(e,t,s){"use strict";s.r(t),s.d(t,"default",(function(){return f}));var n=s(3),i=(s(67),s(318)),r=s(317),o="Physical Units in Python: Part 1 - Emulating Python Primitives",l="Dec 17 2020",a="\nclass MyNumber:\n    def __init__(self, value, units=None):\n        self._value = value\n        self._units = units\n".trim(),c="\nx = MyNumber(5)\nprint(str(x))  # returns <__main__.MyNumber instance at 0x037B3990>\nprint(repr(x))  # also returns <__main__.MyNumber instance at 0x037B3990>\n".trim(),h="\nclass MyNumber:\n    def __init__(self, value, units=None):\n        self._value = value\n        self._units = units\n    def __str__(self):\n        return f'my value is {self._value}'\n    def __repr__(self):\n        return f'my repr is {self._value}'\n".trim(),d="\nx = MyNumber(5)\nprint(f'here is the string: {x}')  # returns here is the string: my value is 5\nprint([x])  # returns [my repr is 5]\n".trim(),u=("\nx = MyNumber(5)\nprint(f'here is the string: {x}')  # returns here is the string: my value is 5\nprint([x])  # returns [my repr is 5]\n".trim(),"\nclass MyNumber:\n    def __init__(self, value, units=None):\n        self._value = value\n        self._units = units\n    def __repr__(self):\n        if self._units:\n            return f'{self._value} {self._units}'\n        else:\n            return f'{self._value}'\n".trim()),_="\nclass MyNumber:\n    def __init__(self, value, units=None):\n        self._value = value\n        self._units = units\n    def __repr__(self):\n        if self._units:\n            return f'{self._value} {self._units}'\n        else:\n            return f'{self._value}'\n    def __add__(self, other):\n        if isinstance(other, MyNumber):\n            return MyNumber(self._value + other._value, self._units)\n        else:\n            return MyNumber(self._value + other, self._units)\n".trim(),j="\nx = MyNumber(5, 'seconds')\ny = x + 3\nprint(type(y))  # returns <class '__main__.MyNumber'\nprint(y)  # returns 8 seconds\n".trim(),b="\ndef __radd__(self, other):\n    if isinstance(other, MyNumber):\n        return MyNumber(self._value + other._value, self._units)\n    else:\n        return MyNumber(self._value + other, self._units)\n".trim();function f(){return Object(n.jsxs)("div",{children:[Object(n.jsx)("h3",{children:o}),Object(n.jsx)("p",{className:"dateText",children:l}),Object(n.jsx)("p",{children:"One problem that comes up when using computer programming to solve physics problems is handling physical units like distance or time. In this series, we'll look at developing a flexible framework for handling units in Python. Part 1 of this series will take a look at some prerequisite Python knowledge that will be useful when creating something that acts like a primitive Python type."}),Object(n.jsx)("h4",{children:'The Python "Dunders"'}),Object(n.jsxs)("p",{children:['Let\'s frst take a look behind the scenes to understand how Python works. It starts with the magical functions often referred to as "dunders", which is short for double underscore. The most common one Pythonistas see is ',Object(n.jsx)("code",{children:"__init__"}),", which is used to instantiate a class. However, Python uses these functions for all sorts of purposes, such as adding or subtracting. Let's make our own class and take a look at manipulating some basic arithmetic. We'll start with a simple class."]}),Object(n.jsx)(i.a,{language:"python",style:r.a,children:a}),Object(n.jsxs)("p",{children:["Note we're using ",Object(n.jsx)("code",{children:"self._value"})," instead of ",Object(n.jsx)("code",{children:"self.value"}),". In Python, it's convention to prefix private variables with an underscore. We're doing this because we don't want users to access the value directly. Instead, we want this class to ",Object(n.jsx)("i",{children:"be"})," the value. For this to happen, let's take a look at two other dunders, ",Object(n.jsx)("code",{children:"__str__"})," and ",Object(n.jsx)("code",{children:"__repr__"}),"."]}),Object(n.jsx)("h4",{children:"The __str__ and __repr__ Dunders"}),Object(n.jsxs)("p",{children:[Object(n.jsx)("code",{children:"__str__"})," is the dunder method that converts an object into a string. ",Object(n.jsx)("code",{children:"__repr__"})," is the dunder method that converts an object into a string representation of the object. The big difference is that ",Object(n.jsx)("code",{children:"__repr__"})," is meant to be unambiguous, whereas",Object(n.jsx)("code",{children:"__str__"})," is just meant to be human-readable."]}),Object(n.jsx)("p",{children:"Let's look at a couple scenarios to understand how these behave. Let's start with our simple class. What happens when we look at the string and repr for this?"}),Object(n.jsx)(i.a,{language:"python",style:r.a,children:c}),Object(n.jsxs)("p",{children:["Note these both return the same thing. This is because the default functionality of ",Object(n.jsx)("code",{children:"__str__"})," is to just return the same thing as ",Object(n.jsx)("code",{children:"__repr__"}),". This will always be the case unless we override ",Object(n.jsx)("code",{children:"__str__"}),". Note the memory address that's returned from ",Object(n.jsx)("code",{children:"__repr__"}),". This memory address is unique to this class instance, which makes it unambiguous."]}),Object(n.jsxs)("p",{children:["Now let's look at what happens when we override ",Object(n.jsx)("code",{children:"__str__"})," and",Object(n.jsx)("code",{children:"__repr__"}),". Here's our updated class."]}),Object(n.jsx)(i.a,{language:"python",style:r.a,children:h}),Object(n.jsx)("p",{children:"We should know how our previous tests should go. Let's look at some more complicated scenarios to see how our instance shows up."}),Object(n.jsx)(i.a,{language:"python",style:r.a,children:d}),Object(n.jsxs)("p",{children:["In the first print statement, we're formatting ",Object(n.jsx)("code",{children:"x"})," into a string. This will convert it to a string and insert it into the string that is being printed. We can see that it's calling ",Object(n.jsx)("code",{children:"__str__"})," in this case."]}),Object(n.jsxs)("p",{children:["In the second print statement, we add our instance to a list, then print that list. When we do that, Python shows us what's in that list by calling ",Object(n.jsx)("code",{children:"__repr__"})," for each item, since that will tell us, unambiguously, what each item is. We can see it's calling ",Object(n.jsx)("code",{children:"__repr__"})," in this case."]}),Object(n.jsxs)("p",{children:["In our case, we want it to return the value and the units. If the units are omitted, we'll leave them out and just return the value. We'll use ",Object(n.jsx)("code",{children:"__repr__"})," in this case since it's intended to be a numeric type. For now, we'll assume ",Object(n.jsx)("code",{children:"value"})," will be a float or int and ",Object(n.jsx)("code",{children:"units"})," will be a string. Since neither of these override the default ",Object(n.jsx)("code",{children:"__str__"}),", we'll convert them to strings in our ",Object(n.jsx)("code",{children:"__repr__"})," to simplify the code. Here's our new class."]}),Object(n.jsx)(i.a,{language:"python",style:r.a,children:u}),Object(n.jsx)("h4",{children:"Dunders for Arithmetic"}),Object(n.jsx)("p",{children:"With that out of the way, let's take a look at some more dunders. this time, we'll look at the ones that are used for basic arithmetic. Here's a quick rundown of all the arithmetic dunders and what they're used for."}),Object(n.jsxs)("ul",{children:[Object(n.jsxs)("li",{children:[Object(n.jsx)("code",{children:"__add__(self, other)"})," is for addition (+)"]}),Object(n.jsxs)("li",{children:[Object(n.jsx)("code",{children:"__sub__(self, other)"})," is for subtraction (-)"]}),Object(n.jsxs)("li",{children:[Object(n.jsx)("code",{children:"__mul__(self, other)"})," is for multiplication (*)"]}),Object(n.jsxs)("li",{children:[Object(n.jsx)("code",{children:"__truediv__(self, other)"})," is for division (/)"]}),Object(n.jsxs)("li",{children:[Object(n.jsx)("code",{children:"__pow__(self, other)"})," is for power (**)"]}),Object(n.jsxs)("li",{children:[Object(n.jsx)("code",{children:"__lt__(self, other)"})," is for less than (<)"]}),Object(n.jsxs)("li",{children:[Object(n.jsx)("code",{children:"__le__(self, other)"})," is for less than or equal to (<=)"]}),Object(n.jsxs)("li",{children:[Object(n.jsx)("code",{children:"__eq__(self, other)"})," is for equal to (==)"]}),Object(n.jsxs)("li",{children:[Object(n.jsx)("code",{children:"__gt__(self, other)"})," is for greater than (>)"]}),Object(n.jsxs)("li",{children:[Object(n.jsx)("code",{children:"__ge__(self, other)"})," is for greater than or equal to (>=)"]})]}),Object(n.jsxs)("p",{children:["This is just scratching the surface. Check out the ",Object(n.jsx)("a",{href:"https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types",children:"Python documentation"})," for more information on emulating data types in Python. For now, we'll stick to these and take a look at them in action. Let's start with addition. We'll account for two use cases."]}),Object(n.jsxs)("ol",{children:[Object(n.jsx)("li",{children:"Adding a float or an int to our class"}),Object(n.jsxs)("li",{children:["Adding another instance of ",Object(n.jsx)("code",{children:"MyNumber"})," to our class"]})]}),Object(n.jsxs)("p",{children:["Let's now add a ",Object(n.jsx)("code",{children:"__add__"})," method to handle this."]}),Object(n.jsx)(i.a,{language:"python",style:r.a,children:_}),Object(n.jsxs)("p",{children:["We're first checking to see if the other thing we're adding is another instance of ",Object(n.jsx)("code",{children:"MyNumber"}),". If it is, we'll add the two values together. Down the road, we'll probably want to handle unit compatibility and conversion, but we'll leave it at this for now. If the other object isn't an instance of ",Object(n.jsx)("code",{children:"MyNumber"}),", then we'll just add it to our value. In both cases, we leave it to ",Object(n.jsx)("code",{children:"self._value"})," to handle the addition. Since the value is an int or float, this will behave just like regular int or float addition. For example, an error will be raised if we try adding a string. Let's see it in action."]}),Object(n.jsx)(i.a,{language:"python",style:r.a,children:j}),Object(n.jsxs)("p",{children:["Great! We see it returns an instance of ",Object(n.jsx)("code",{children:"MyNumber"})," with the value of 8 and units of seconds."]}),Object(n.jsxs)("p",{children:["Note that we get an error if we try ",Object(n.jsx)("code",{children:"y = 3 + x"}),". This is because there's another dunder called ",Object(n.jsx)("code",{children:"__radd__"})," that handles the case where our object is on the right side of the addition. Note that ",Object(n.jsx)("code",{children:"__radd__"})," is only called when the object on the left either doesn't have its own ",Object(n.jsx)("code",{children:"__add__"})," method or it doesn't know how to add the two objects together. We can add an ",Object(n.jsx)("code",{children:"__radd__"})," method to our class to handle this case. It would look just like our ",Object(n.jsx)("code",{children:"__add__"})," method."]}),Object(n.jsx)(i.a,{language:"python",style:r.a,children:b}),Object(n.jsx)("p",{children:"That's where we'll stop for now. I encourage you to test out the other dunders and get a feel for how other arithmetic is handled. In the next post, we'll take a look at handling units. Until then, happy coding!"})]})}}}]);
//# sourceMappingURL=10.2140fef5.chunk.js.map